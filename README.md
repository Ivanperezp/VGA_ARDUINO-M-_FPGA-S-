# VIDEO_ARDUINO-M-_FPGA-S-
This repository contains a method to use an Arduino as a master and a FPGA as a slave in order to transmit video by a VGA port to a monitor by SPI protocol.
This project is made up by six files: arduino.ino, spiSlave.v, vram.v, main.v, vga_sync.v and top_vga.v, which can be found in this repository. The following is the explanation of each file, starting with the file that sends the data from the arduino and ending with the one that transmit the data to the monitor.

---
## arduino.ino
This file allows the sending of data from the arduino (master) to the FPGA (slave) using SPI comunication. 

### Header and Definitions
```cpp
#include <SPI.h>

#define SS_PIN 10       // Slave Select pin
#define WIDTH 640      // Screen width (unused in this code)
#define HEIGHT 480     // Screen height (unused in this code)
#define SQUARE_SIZE 32  // Chessboard square size (unused in this code)
```
The SPI.h library provides functions for SPI communication.

**Pin Definitions:**

**SS_PIN (Pin 10):** Slave Select pin used to enable/disable the slave device

**Other definitions** (WIDTH, HEIGHT, SQUARE_SIZE) are declared but not used in this code
#### Setup
```cpp
void setup() {
  // Initialize SPI as master
  SPI.begin();
  
  // Configure SS pin
  pinMode(SS_PIN, OUTPUT);
  digitalWrite(SS_PIN, HIGH);
// Configure SPI speed and mode
  SPI.beginTransaction(SPISettings(8000000, MSBFIRST, SPI_MODE0));
// Select slave
  digitalWrite(SS_PIN, LOW);

  for (int i = 0; i < 1200; i++) {
    SPI.transfer(random());
  }

  // Deselect slave
  digitalWrite(SS_PIN, HIGH);
}
```
SPI.begin(): Initializes the SPI bus and sets the Arduino as master

**SS pin configuration:** Set as output (required for master).Set HIGH initially to deselect the slave

**SPISettings**: Clock speed (8 MHz),bit order (MSBFIRST), SPI_MODE0 (Clock polarity 0, phase 0). clock polarity 0 means that SPI clock (SCLK) is low (0) when idle, and phase 0 means that the data is sampled on the rising edge of the clock
**Slave selection:**  Set SS_PIN LOW to activate slave

**Data transfer:** Sends 1200 random bytes using SPI.transfer() Each byte is generated by random() function

**Slave deselection:** Set SS_PIN HIGH when communication is complete

---

### spi.Slave.v
This Verilog module implements an SPI slave device (FPGA in this case) compatible with SPI Mode 0 (CPOL=0, CPHA=0). It receives data from an SPI master (Arduino) and provides the received data to the FPGA system.

#### Module Interface

```verilog
module spiSlave (
    input wire clk,           // FPGA system clock
    input wire rst_n,         // Active low reset
    input wire sclk,          // SPI clock from Arduino
    input wire cs_n,          // Chip select (active low)
    input wire mosi,          // Master out, slave in
    output reg miso,          // Master in, slave out
    output reg [7:0] rx_data, // Received data
    output reg rx_valid       // Received data valid flag
);
```
**Port Descriptions:**

* clk: Main FPGA system clock

* rst_n: Active-low reset signal

* sclk: SPI clock from master device

* cs_n: Chip select (active low) from master

* mosi: Master Out Slave In data line

* miso: Master In Slave Out data line (note: not fully implemented in this code)

* rx_data: 8-bit received data register

* rx_valid: Flag indicating when new data is available in rx_data

It is important to note that the SCLK and CLK clocks are different, the former is associated with SPI communication, while the latter is the internal clock of the FPGA (50 MHz). In order to avoid instabilities, it is crucial that a clock synchronisation process is performed so that the SPI clock enters the FPGA clock domain. The following is the explanation of the synchronization process.

```verilog
// Synchronization registers
reg [2:0] sclk_sync;
reg [1:0] cs_n_sync;
reg [1:0] mosi_sync;

// Edge detection
wire sclk_rising;
wire sclk_falling;

// SPI state tracking
reg [2:0] bit_count;
reg [7:0] rx_shift;
```

as can be seen, there is a 3-stage synchronizer for sclk (SPI clock) and 2-stage synchronizers for cs_n and mosi. but, Why 3-stage for sclk but 2-stage for others? sclk is critical because it determines when data is sampled. A 3-stage synchronizer reduces the chance of instability glitches. other signals are not critical for timing, so 2 stages are sufficient 

```verilog
// Synchronize inputs to FPGA clock domain
always @(posedge clk or negedge rst_n) begin	
	if (!rst_n) begin
		sclk_sync <= 3'b000;
		cs_n_sync <= 2'b11;
		mosi_sync <= 2'b00;
	end else begin
		sclk_sync <= {sclk_sync[1:0], sclk};
		cs_n_sync <= {cs_n_sync[0], cs_n};
		mosi_sync <= {mosi_sync[0], mosi};
	end
end
	
```
Each time a reset signal is detected, the system will return to its default values, on the other hand, with each rising edge of the CLK clock, the bit of its current value will be concatenated in sclk_sync with the two immediately preceding bits. The following table best illustrates this configuration

| (`clk`) time| `sclk` (input) | `sclk_sync` (before) | operation               | `sclk_sync` (after) |                      |
|----------------|------------------|---------------------|-------------------------|-----------------------|--------------------------------|
| t=1            | 1                | `000`               | `{00,1}` → `001`        | `001`                 | first input bit           |
| t=2            | 0                | `001`               | `{01,0}` → `010`        | `010`                 | change to 0                     |
| t=3            | 1                | `010`               | `{10,1}` → `101`        | `101`                 | New high pulse               |
| t=4            | 1                | `101`               | `{01,1}` → `011`        | `011`                 | remains in high state                     |
| t=5            | 0                | `011`               | `{11,0}` → `110`        | `110`                 | down flank               |


All this is done in order that the following instruction detects edges when comparing bits as follows 

```verilog
// Edge detection logic
assign sclk_rising = (sclk_sync[2:1] == 2'b01);
assign sclk_falling = (sclk_sync[2:1] == 2'b10);
```
If the two oldest bits of sclk_sync correspond to 01 we are on a rising edge, so sclk_rising is set as high, while if the opposite is true and the two bits correspond to 10 sclk_falling is set as high. Now that system has been synchronised, we can continue with main logic as follows

```verilog
always @(posedge clk or negedge rst_n) begin
    if (!rst_n) begin
        // Reset all registers
        bit_count <= 3'b000;
        rx_shift <= 8'h00;
        rx_data <= 8'h00;
        rx_valid <= 1'b0;
    end else begin
        // Default assignment
        rx_valid <= 1'b0;
        
        // Only process when chip is selected
        if (!cs_n_sync[1]) begin
            // Sample on rising edge (SPI Mode 0)
            if (sclk_rising) begin
                // Shift in new bit (MSB first)
                rx_shift <= {rx_shift[6:0], mosi_sync[1]};
                
                // Check if complete byte received
                if (bit_count == 3'b111) begin
                    rx_data <= {rx_shift[6:0], mosi_sync[1]};
                    rx_valid <= 1'b1;
                    bit_count <= 3'b000;
                end else begin
                    bit_count <= bit_count + 1;
                end
            end
        end
    end
end
```
If a reset signal is detected all values are set as default. Next, the line rx_valid <= 1'b0; ensures the valid pulse only lasts one clock cycle. Then, the instruction if (!cs_n_sync[1]) begin ensures that the logic only activates when chip select is low (slave is selected). Finally, if a risign edge is detected (if (sclk_rising) begin) the main operation is started. Note that all this instructions uses the synchronised version of variables.

The data shifting operation rx_shift <= {rx_shift[6:0], mosi_sync[1]}; performs a left shift that takes the current 7 most significant bits of rx_shift (bits [6:0]) and appends the newly received bit from mosi_sync[1] at the least significant bit (LSB) position, implementing MSB-first (most significant bit first) reception which is the SPI standard convention. This approach gradually builds the complete byte by shifting each new received bit into the left side of the register while inserting the incoming bit at the rightmost position, effectively assembling the data stream one bit at a time with the first received bit ending up as the highest-order bit in the final byte. The operation occurs on every rising edge of the synchronized SPI clock when the slave is selected, maintaining proper bit order and timing according to the SPI protocol specifications.
Finally, checks if all 8 bits have been received (count = 7) when it is true captures full byte: rx_data <= {rx_shift[6:0], mosi_sync[1]}, and then combines previous 7 bits + new 8th bit. set rx_valid as high for one clock cycle and resets bit_count to 0

For better understanding, time diagram is presented
# SPI Slave Timing Diagram (Mode 0 - CPOL=0, CPHA=0)

| clk | !rst_n | cs_n_sync[1] | sclk_sync[1] | mosi_sync[1] | bit_count | rx_shift (bin) | rx_data (hex) | rx_valid | Event Description               |
|-----|--------|--------------|--------------|--------------|-----------|----------------|---------------|----------|---------------------------------|
| ↑   | 1      | 1            | 0            | X            | 0         | 00000000       | XX            | 0        | Idle (chip not selected)        |
| ↑   | 1      | 0            | 0            | 1            | 0         | 00000000       | XX            | 0        | Chip selected (start of frame)  |
| ↑   | 1      | 0            | ↑ (0→1)      | 1            | 0         | 00000001       | XX            | 0        | 1st rising edge - bit 0 (MSB)   |
| ↑   | 1      | 0            | ↑ (0→1)      | 0            | 1         | 00000010       | XX            | 0        | 2nd rising edge - bit 1         |
| ↑   | 1      | 0            | ↑ (0→1)      | 1            | 2         | 00000101       | XX            | 0        | 3rd rising edge - bit 2         |
| ↑   | 1      | 0            | ↑ (0→1)      | 0            | 3         | 00001010       | XX            | 0        | 4th rising edge - bit 3         |
| ↑   | 1      | 0            | ↑ (0→1)      | 1            | 4         | 00010101       | XX            | 0        | 5th rising edge - bit 4         |
| ↑   | 1      | 0            | ↑ (0→1)      | 0            | 5         | 00101010       | XX            | 0        | 6th rising edge - bit 5         |
| ↑   | 1      | 0            | ↑ (0→1)      | 1            | 6         | 01010101       | XX            | 0        | 7th rising edge - bit 6         |
| ↑   | 1      | 0            | ↑ (0→1)      | 0            | 7         | 10101010       | XX            | 0        | 8th rising edge - bit 7 (LSB)   |
| ↑   | 1      | 0            | 1            | X            | 0         | 01010100       | AA            | 1        | Byte complete (rx_valid pulse)  |
| ↑   | 1      | 1            | X            | X            | 0         | 01010100       | AA            | 0        | Chip deselected                 |



